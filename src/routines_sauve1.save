#include <genesis.h>
#include <main.h>
#include <init.h>
#include <variables.h>
#include <palettes.h>
#include <maps_NIVEAU1.h>
#include <tilemaps_ennemis.h>
#include <GestionPAD.h>
#include <sprites_JEU.h>

void updateCamera_Niveau1()
{
    // MOUVEMENT CAMERA //
    CamPosX-=1;

    if(CamPosX<-4336)
    {
        CamPosX=-4336;
    }

    tilemapOffset=(CamPosX>>3)*-1;




    // MISE A JOUR TILEMAP //
    if(CamPosX>-4336)
    {

        // DEPLACEMENT CAMERA //
        // BG_A
        for (i=0; i<28; i++)
        {
            scrollOffset_TILE_NIVEAU1_BGA[i]=CamPosX;
        }
        
        // scrolling par tile
        VDP_setHorizontalScrollTile(BG_A, 7, scrollOffset_TILE_NIVEAU1_BGA, 21, DMA_QUEUE);
        

   
        // BG_B
        // NUAGES
        for (i=0; i<17; i++)
        {
            scrollOffset_TILE_NIVEAU1_BGB[i]=CamPosX>>1;
        }
        // EAU
        for (i=17; i<21; i++)
        {
            scrollOffset_TILE_NIVEAU1_BGB[i]=CamPosX;
        }   

        VDP_setHorizontalScrollTile(BG_B, 7, scrollOffset_TILE_NIVEAU1_BGB, 24, DMA_QUEUE);
    }
}

void updateTiles_Niveau1()
{
    // MISE A JOUR TILEMAP //
    if(CamPosX>-4336)
    {
        if (CamPosX%8==0)
        {
            if (tilemapOffset>0 && tilemapOffset<520)
            {
                VDP_setTileMapColumnEx(BG_B, image_NIVEAU1_BGB.tilemap, TILE_ATTR_FULL(PAL2, FALSE, FALSE, FALSE, 16), (tilemapOffset>>1)-2, 62+(tilemapOffset>>1), 7, 20, DMA_QUEUE);
                VDP_setTileMapColumnEx(BG_B, image_NIVEAU1_BGB.tilemap, TILE_ATTR_FULL(PAL2, TRUE, FALSE, FALSE, 16), (tilemapOffset>>1)-2, 62+(tilemapOffset>>1), 27, 4, DMA_QUEUE);


                VDP_setTileMapColumnEx(BG_A, image_NIVEAU1_BGA.tilemap, TILE_ATTR_FULL(PAL3, TRUE, FALSE, FALSE, 191), tilemapOffset-2, 62+tilemapOffset, 7, 21, DMA_QUEUE);
            }
        }
    }


    // CHANGEMENTS PALETTE
    if(CamPosX<-4016 && CamPosX>-4018)
    {
        //PAL_setColors(49, &palette_NIVEAU1_BGA2, 6, DMA);
        PAL_setPaletteColors(48, &palette_NIVEAU1_BGA2, DMA);
    }


}

void collision_Decor(SpriteJoueur_ *spr)
{
    // Point collision bas gauche
    spr->pt_Coll1_X=SPR_getPositionX(spr->SpriteJ)+8;
    spr->pt_Coll1_Y=SPR_getPositionY(spr->SpriteJ)+32;

    // Point collision bas droite
    spr->pt_Coll2_X=SPR_getPositionX(spr->SpriteJ)+23;
    //spr->pt_Coll2_Y=spr->pt_Coll1_Y;


    // Récuperation ID de tile de collision
    if(CamPosX>=7)
    {
        tileID_G=MAP_getTile( tilemapCollision, (spr->pt_Coll1_X>>3) - (CamPosX>>3), spr->pt_Coll1_Y>>3 ) & TILE_INDEX_MASK;
        tileID_D=MAP_getTile( tilemapCollision, (spr->pt_Coll2_X>>3) - (CamPosX>>3), spr->pt_Coll1_Y>>3 ) & TILE_INDEX_MASK;
    }
    else
    {
        tileID_G=MAP_getTile( tilemapCollision, (spr->pt_Coll1_X>>3) - (CamPosX>>3)+1, spr->pt_Coll1_Y>>3 ) & TILE_INDEX_MASK;
        tileID_D=MAP_getTile( tilemapCollision, (spr->pt_Coll2_X>>3) - (CamPosX>>3)+1, spr->pt_Coll1_Y>>3 ) & TILE_INDEX_MASK;
    }
}

void creaEnnemis_Niveau1()
{
    // Si CamPosX est divisible par 8 //
    if (CamPosX%8==0)
    {
        if (CamPosX>>3==tilemapCreaEnnemis_Niveau1[0][indexCreaEnnemis])
        {
            // Récupération de l'ID de la tile //
            // Conversion de const à u16 //
            tileID_ENNEMI=MAP_getTile( tilemapEnnemis, (u16)tilemapCreaEnnemis_Niveau1[0][indexCreaEnnemis], (u16)tilemapCreaEnnemis_Niveau1[1][indexCreaEnnemis] ) & TILE_INDEX_MASK;
            
            // On scanne les emplacements vides
            for(i=0;i<11;i++)
            {
                // Si on trouve un emplacement vide
                if(Ennemi[i]->Init==0)
                {
                    switch(tileID_ENNEMI)
                    {
                    // ESCARGOTS H //
                    case 1:
                    Ennemi[i]->Init=1;
                    Ennemi[i]->ID=1;
                    Ennemi[i]->PointsVie=1;

                    Ennemi[i]->SpriteE = SPR_addSprite(&tiles_Sprite_ESCARGOT_H, 336, (u16)tilemapCreaEnnemis_Niveau1[1][indexCreaEnnemis]<<3, TILE_ATTR(PAL0, FALSE, FALSE, FALSE));

                    indexCreaEnnemis++;
                    break;

                    //
                    case 2:
                    
                    indexCreaEnnemis++;
                    break;
                    }
                }
            }
        }   
    }
}